/** @file SynchroRX.cpp
 * Contains the command line program to synchronize receiver and computer to allow reception of GPS receiver data.
 * The current implementation of is program synchronizes Windows comm ports and SiRF IV receiver.
 *<p>Usage:
 *<p>SynchroRX.exe {options}
 *<p>Options are:
 *	- -a PAT or --patience=PAT : Maximum number of bytes to read when waiting for a packet start. Default value PAT = 500
 *	- -h or --help : Show usage data. Default value HELP=FALSE
 *	- -l LOGLEVEL or --llevel=LOGLEVEL : Maximum level to log (SEVERE, WARNING, INFO, CONFIG, FINE, FINER, FINEST). Default value LOGLEVEL = INFO
 *	- -p COMPORT or --port=COMPORT : Serial port name where receiver is connected. Default value COMPORT = COM35
 *	- -m MODE or --mode=MODE : Set receiver protocol to NMEA or OSP. Default value MODE = NMEA
 *<p>
 *Copyright 2015 Francisco Cancillo
 *<p>
 *This file is part of the RXtoRINEX tool.
 *<p>
 *RXtoRINEX is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
 *as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 *RXtoRINEX is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 *warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *See the GNU General Public License for more details.
 *A copy of the GNU General Public License can be found at <http://www.gnu.org/licenses/>.
 *
 *Ver.	|Date	|Reason for change
 *------+-------+------------------
 *V1.0	|2/2015	|First release
 *V1.1	|2/2016	|Minor improvements for logging messages
 */

//from CommonClasses
#include "ArgParser.h"
#include "Logger.h"
#include "Utilities.h"
//from SerialTxRx
#include "SerialTxRx.h"

#include <stdio.h>

using namespace std;

//@cond DUMMY
///The command line format
const string CMDLINE = "SynchroRX.exe {options}";
const string MYVER = " V1.1";
///Default baud rate for OSP binary data transfers
const int OSPbRate = 57600;
///Default baud rate for NMEA ASCII data transfers
const int NMEAbRate = 9600;
///The parser object to store options and operators passed in the comman line
ArgParser parser;
//Metavariables for options
int COMPORT, HELP, LOGLEVEL, MODE, PAT; //metavariables for options in the command line call
//Metavariables for operators

//Protocols / modes used by the receiver to exchange data
enum protocol {OSP=0, NMEA, UNKNOWN};
//Bit rates that can be used 
const int bRates[] = {NMEAbRate, OSPbRate, 1200, 2400, 4800, 38400, 115200, 0};
//arguments for receiver commands
//NMEA cmd args to change mode from NMEA to OSP at 57600 bps baud rate 
char* cmdNMEA100 = "0,57600,8,1,0";
//OSP cmd args to set baud rate at 57600 bps
char* cmdOSP134 = "00 00 E1 00 08 01 00 00";
//OSP cmd args to change mode from OSP to NMEA at 9600 bps baud rate 
char* cmdOSP129 = "02 01 01 00 01 01 01 05 01 01 01 00 01 00 01 00 01 00 01 00 01 25 80";
//functions in this module
bool checkProtocol(protocol prtcl, SerialTxRx port, int ntimes, Logger* plog);
string protocolTXT (protocol p);
//@endcond 

/**main sets the communication between computer and receiver at the speed and mode requested. 
 *<p>The receiver state is defined by the following:
 *	- The serial port bit rate, stop bits, and parity it is using
 *	- The protocol mode it is using to send data: NMEA or OSP
 *	- If data is flowing from the receiver or not
 *<p>The computer data acquisition process state is defined by:
 *	- The serial port (port name) it is using for the communication with the GPS receiver
 *	- The serial port bit rate, stop bits, and parity being used
 *	- The type of data expected: NMEA or OSP
 *<p>To allow communication between GPS receiver and computer, states of both elements shall be synchronized
 * according to the needs stated. To synchronize computer and receiver their current states shall be known, and changed if different.
 *<p>To know the receiver state is necessary to communicate with it, setting first the computer port at 
 * the same speed, stop bits and parity that the receiver. This will allow receiving and analyzing the data being
 * generated by the receiver to know the protocol it is using.
 *<p>As receiver state may be not known initially, it would be necessary to scan at different speeds data being received to identify the protocol. 
 *<p>To allow synchronization it is assumed the following for the receiver:
 * - It is providing data continuously, ASCII NMEA or binary OSP messages, depending on the mode.
 * - It is receiving/sending data at 1200, 2400, 4800, 9600, 38400, 57600 or 115200 bps, with one stop bit and parity none.
 *<p>After synchronization, bit rates will be set to 9600 bps when exchanging NMEA data
 * or to 57600 bps when exchanging OSP messages..
 *
 * @param argc	the number of arguments passed from the command line
 * @param argv	array with argument values passed
 * @return the exit status according to the following values and meaning:
 *	- (0) Receiver protocol mode changed to requested value (OSP or NMEA). Baud rate set accordingly.
 *	- (1) Error in the command line arguments passed to the program
 *	- (2) An error occurred when setting computer port parameters, or when sending or reciving data. See log file for details.
 *	- (3) Unable to change to the protocol mode requested. See log file for details.
 */
int main(int argc, char** argv) {
	char textBuf[200];
	sprintf(textBuf, "NMEA or OSP to set receiver protocol to NMEA at %d baud or OSP at %d", NMEAbRate, OSPbRate);
	/**The main process sequence follows:*/
	/// 1- Defines and sets the error logger object
	Logger log("LogFile.txt", string(), string(argv[0]) + MYVER + string(" START"));
	/// 2- Setups the valid options in the command line. They will be used by the argument/option parser
	MODE = parser.addOption("-m", "--mode", "MODE", textBuf, "NMEA");
	COMPORT = parser.addOption("-p", "--port", "COMPORT", "Serial port name where receiver is connected", "COM35");
	LOGLEVEL = parser.addOption("-l", "--llevel", "LOGLEVEL", "Maximum level to log (SEVERE, WARNING, INFO, CONFIG, FINE, FINER, FINEST)", "INFO");
	HELP = parser.addOption("-h", "--help", "HELP", "Show usage data", false);
	PAT = parser.addOption("-a", "--patience", "PAT", "Maximum number of bytes to read when waiting for a packet start", "500");
	/// 3- Parses arguments in the command line extracting options and operators
	try {
		parser.parseArgs(argc, argv);
	}  catch (string error) {
		parser.usage("Argument error: " + error, CMDLINE);
		log.severe(error);
		return 1;
	}
	log.info(parser.showOptValues());
	if (parser.getBoolOpt(HELP)) {
		parser.usage("checks and/or sets the communications port and the SiRF IV receiver state", CMDLINE);
		return 0;
	}
	/// 4- Sets logging level stated in option
	log.setLevel(parser.getStrOpt(LOGLEVEL));
	/// 5- Gets from option the protocol mode to be used
	protocol wantedMode = NMEA;		//default values
	int wantedBaud = NMEAbRate;
	if(parser.getStrOpt(MODE).compare("OSP") == 0) {
		wantedMode = OSP;
		wantedBaud = OSPbRate;
		log.info(string("Wanted receiver mode: OSP at " + to_string((long long) OSPbRate)));
	} else log.info(string("Wanted receiver mode: NMEA at " + to_string((long long) NMEAbRate)));
	//Set params for the comm port
	SerialTxRx port;
	int currentSize = -1;
	bool currentParity;
	int currentBaud;
	protocol currentMode = UNKNOWN;
	try {
		/// 6 - Checks current computer baud rate
		port.openPort(parser.getStrOpt(COMPORT));
		port.getPortParams(currentBaud, currentSize, currentParity);
		sprintf(textBuf, "Computer port initial settings: BaudRate=%d; ByteSize=%d; Parity=%c", currentBaud, currentSize, currentParity?'T':'F');
		log.info(string(textBuf));
		/// 6 - Discover initial receiver mode and baud rate, first look for "most likely" ones:
		/// - if the computer computer baud rate is not the NMEA or OSP one, set the NMEA rate
		/// - if computer baud rate is the NMEA one, check if receiver is sending NMEA messages
		/// - if computer baud rate is the OSP one, check if receiver is sending OSP messages
		if (currentBaud!=NMEAbRate && currentBaud!=OSPbRate) {
			log.info("As computer port baud rate is not for NMEA or OSP, set NMEA rate");
			port.setPortParams(NMEAbRate);
			port.getPortParams(currentBaud, currentSize, currentParity);
			sprintf(textBuf, "Computer port set at: BaudRate=%d; ByteSize=%d; Parity=%c", currentBaud, currentSize, currentParity?'T':'F');
			log.info(string(textBuf));
		}
		if (currentBaud == NMEAbRate) {
			log.info("As computer port baud rate is for NMEA, check if receiver is in NMEA mode");
			if(checkProtocol(NMEA, port, 10, &log)) currentMode = NMEA;
			else {
				log.info("Receiver not sending NMEA. Try at OSP rate");
				port.setPortParams(OSPbRate);
				port.getPortParams(currentBaud, currentSize, currentParity);
				sprintf(textBuf, "Computer port set at: BaudRate=%d; ByteSize=%d; Parity=%c", currentBaud, currentSize, currentParity?'T':'F');
				log.info(string(textBuf));
				if(checkProtocol(OSP, port, 10, &log)) currentMode = OSP;
			}
		} else if (currentBaud == OSPbRate) {
			log.info("As computer port baud rate is for OSP, check if receiver is in OSP mode");
			if(checkProtocol(OSP, port, 2, &log)) currentMode = OSP;
			else {
				log.info("Receiver not sending OSP. Try at NMEA rate");
				port.setPortParams(NMEAbRate);
				port.getPortParams(currentBaud, currentSize, currentParity);
				sprintf(textBuf, "Computer port set at: BaudRate=%d; ByteSize=%d; Parity=%c", currentBaud, currentSize, currentParity?'T':'F');
				if(checkProtocol(NMEA, port, 2, &log)) currentMode = NMEA;
			}
		}
		log.info("Receiver initial protocol: " + protocolTXT(currentMode));
		/// 9- When failed to discover receiver mode at usual baud rates, iterate over all baud rates
		///		setting computer port speed and sending NMEA and OSP commands to set its mode to OSP at 57600 bps.
		///		Then checks if the current receiver mode has changed to OSP.
		if (currentMode == UNKNOWN) {	//mode not identified at usual baud rates
			log.info("Iterate over all baud rates trying to set receiver in OSP mode at 57600 bps");
			//broadcast a change to OSP at 57600 in the receiver using all baud rates in the computer
			for(int i=0; bRates[i]!=0; i++) {
				port.setPortParams(bRates[i]);
				port.writeNMEAcmd(100,cmdNMEA100); port.writeNMEAcmd(100,cmdNMEA100);
				port.getPortParams(currentBaud, currentSize, currentParity);
				sprintf(textBuf, "Computer port set at BaudRate %d and NMEA command sent to change to OSP mode at 57600 bps", currentBaud);
				log.info(string(textBuf));
			}
			for(int i=0; bRates[i]!=0; i++) {
				port.setPortParams(bRates[i]);
				port.writeOSPcmd(134,cmdOSP134);
				port.writeOSPcmd(134,cmdOSP134);
				port.getPortParams(currentBaud, currentSize, currentParity);
				sprintf(textBuf, "Computer port set at BaudRate %d and OSP command sent to change at 57600 bps", currentBaud);
				log.info(string(textBuf));
			}
			port.setPortParams(OSPbRate);
			port.getPortParams(currentBaud, currentSize, currentParity);
			sprintf(textBuf, "Computer port set at BaudRate %d to check if receiver is sending OSP at 57600 bps", currentBaud);
			log.info(string(textBuf));
			if(checkProtocol(OSP, port, 2, &log)) currentMode = OSP;
			log.info("After broadcasting change to OSP, receiver protocol is " + protocolTXT(currentMode));
		}
		/// 10- If the current receiver mode is OSP, but it is wanted to be NMEA, sends a OSP command
		///		to change it, and sets computer com speed at NMEAbRate. Then checks if new mode has changed to NMEA.
		if (currentMode==OSP && wantedMode==NMEA) {
			log.info("In receiver OSP mode, sends MID129 to change to NMEA at 9600 bps");
			port.writeOSPcmd(129,cmdOSP129);
			port.setPortParams(NMEAbRate);
			if(checkProtocol(NMEA, port, 10, &log)) currentMode = NMEA;
		/// 11- If the current receiver mode is NMEA, but it is wanted to be OSP, sends a NMEA command
		///		to change it, and sets computer com speed at OSPbRate Then checks if new mode has changed to OSP.
		} else if (currentMode==NMEA && wantedMode==OSP) {
			log.info("In receiver NMEA mode, sends NMEA 100 to change to osp at 57600 bps");
			port.writeNMEAcmd(100,cmdNMEA100);
			port.setPortParams(OSPbRate);
			if(checkProtocol(OSP, port, 10, &log)) currentMode = OSP;
		}
		sprintf(textBuf, "Receiver final protocol: %s. Change is %s", protocolTXT(currentMode).c_str(), currentMode==wantedMode? "OK" : "NOK");
		log.info(string(textBuf));
		port.getPortParams(currentBaud, currentSize, currentParity);
		sprintf(textBuf, "Computer port final settings: BaudRate=%d; ByteSize=%d; Parity=%c\n", currentBaud, currentSize, currentParity?'T':'F');
		log.info(string(textBuf));
	} catch (string error) {
		log.severe(error);
		return 2;
	}
	/// 12- Verify if the resulting current mode is the wanted one, and returns value accordingly
	if (currentMode!=wantedMode) return 3;
	return 0;
}

//@cond DUMMY
/**checkProtocol
 * checks if the given protocol is currently being used by the GPS receiver.
 *
 * @param prtcl the protocol to be checked (OSP or NMEA)
 * @param port the computer SerialTxRx object being used for communications with the GNSS receiver
 * @param ntimes the maximum number of tryes for receiving a message before returning a false result 
 * @param plog the pointer to the logger
 * @return true when a correct message of the given protocol is received, false otherwise
 */
bool checkProtocol(protocol prtcl, SerialTxRx port, int ntimes, Logger* plog) {
	int resultCode;
	string logMsg;
	int ntry = 0;
	int patience = stoi(parser.getStrOpt(PAT));
	do {
		resultCode = prtcl==NMEA? port.readNMEAmsg(patience) : port.readOSPmsg(patience);
		ntimes--;
		ntry++;
	} while (resultCode!=0 && ntimes>0);
	//log result
	if (prtcl == NMEA) {
		logMsg = "Checked receiver NMEA mode: In try " + to_string((long long) ntry) + ", ";
		switch (resultCode) {
		case 0: logMsg += "message OK"; break;
		case 1: logMsg += "checksum error"; break;
		case 2: logMsg += "message too short (<$XXX*SS)"; break;
		case 3: logMsg += "no NMEA messages, or input error occurred, or EOF"; break;
		case 4: logMsg += "no NMEA start received in " + to_string((long long) patience) + " bytes"; break;
		default: logMsg += "UNKNOWN";
		}
		plog->info(logMsg);
		if (resultCode == 0) plog->fine("NMEA message received: " + string((char*) port.payBuff));
	} else {
		logMsg = "Checked receiver OSP mode: In try " + to_string((long long) ntry) + ", ";
		switch (resultCode) {
		case 0: logMsg += "message OK"; break;
		case 1: logMsg += "checksum error"; break;
		case 2: logMsg += "error reading payload or few bytes"; break;
		case 3: logMsg += "payload length out of margin"; break;
		case 4:
		case 5: logMsg += "error reading payload length"; break;
		case 6: logMsg += "no OSP start received in " + to_string((long long) patience) + " bytes"; break;
		default: logMsg += "UNKNOWN";
		}
		plog->info(logMsg);
		if (resultCode == 0) plog->fine("OSP message received: MID=" + to_string((long long) port.payBuff[0]) + " len=" + to_string((long long) port.payloadLen));
	}
	return resultCode == 0;
}

/**protocolTXT
 * gives a readable description on the protocol
 */
string protocolTXT (protocol p) {
	switch (p) {
	case NMEA: return "NMEA";
	case OSP: return "OSP";
	default: return "UNKNOWN";
	}
}
//@endcond 
